{
  "updatedAt": "2026-02-16T07:04:59.470Z",
  "createdAt": "2026-02-06T08:45:26.643Z",
  "id": "__WF_ID:WF7: Integration Hub__",
  "name": "WF7: Integration Hub",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 3
            }
          ]
        }
      },
      "id": "sync-trigger",
      "name": "Daily 3 AM Sync",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "integration-sync",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "manual-trigger",
      "name": "Manual Sync Request",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        208
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  property_id,\n  property_name,\n  calendar_url,\n  settings->>'airbnb_calendar_url' AS airbnb_calendar_url,\n  settings->>'vrbo_calendar_url' AS vrbo_calendar_url,\n  settings->>'booking_com_calendar_url' AS booking_com_calendar_url,\n  settings->>'google_calendar_id' AS google_calendar_id,\n  settings->>'ical_export_url' AS ical_export_url,\n  last_calendar_sync,\n  owner_contact,\n  COALESCE(settings->>'preferred_platform', 'telegram') AS preferred_platform,\n  customer_id\nFROM property_configurations\nWHERE property_status = 'active'\n  AND calendar_sync_enabled = true\n  AND (calendar_url IS NOT NULL\n       OR settings->>'airbnb_calendar_url' IS NOT NULL\n       OR settings->>'vrbo_calendar_url' IS NOT NULL\n       OR settings->>'booking_com_calendar_url' IS NOT NULL)",
        "options": {}
      },
      "id": "get-properties",
      "name": "Get Properties with Integrations",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        224,
        112
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "postgres-cred",
          "name": "[Client] PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "loop-properties",
      "name": "Loop Properties",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        448,
        112
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare calendar URLs for fetching\nconst property = $input.item.json;\nconst calendars = [];\n\nif (property.airbnb_calendar_url) {\n  calendars.push({\n    platform: 'airbnb',\n    url: property.airbnb_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\nif (property.vrbo_calendar_url) {\n  calendars.push({\n    platform: 'vrbo',\n    url: property.vrbo_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\nif (property.booking_com_calendar_url) {\n  calendars.push({\n    platform: 'booking_com',\n    url: property.booking_com_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\n// Fallback: use the main calendar_url if no platform-specific URLs\nif (calendars.length === 0 && property.calendar_url) {\n  calendars.push({\n    platform: 'ical',\n    url: property.calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\n\n// If no calendar URLs found, return empty with flag\nif (calendars.length === 0) {\n  return [{ json: { property_id: property.property_id, skip: true, reason: 'No calendar URLs configured' } }];\n}\n\nreturn calendars.map(c => ({ json: c }));"
      },
      "id": "prepare-urls",
      "name": "Prepare Calendar URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        112
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "fetch-ical",
      "name": "Fetch iCal",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        112
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse iCal data and extract events\nconst input = $input.item.json;\nconst icalData = typeof input === 'string' ? input : input.data || '';\nconst property_id = $('Prepare Calendar URLs').item.json.property_id;\nconst platform = $('Prepare Calendar URLs').item.json.platform;\n\nconst events = [];\n\n// Simple iCal parser\nconst lines = icalData.split(/\\r?\\n/);\nlet currentEvent = null;\n\nfor (const line of lines) {\n  if (line.startsWith('BEGIN:VEVENT')) {\n    currentEvent = {};\n  } else if (line.startsWith('END:VEVENT') && currentEvent) {\n    if (currentEvent.dtstart && currentEvent.dtend) {\n      events.push({\n        property_id: property_id,\n        platform: platform,\n        external_id: currentEvent.uid || `${platform}_${Date.now()}`,\n        summary: currentEvent.summary || 'Blocked',\n        check_in: currentEvent.dtstart,\n        check_out: currentEvent.dtend,\n        description: currentEvent.description || ''\n      });\n    }\n    currentEvent = null;\n  } else if (currentEvent) {\n    const [key, ...valueParts] = line.split(':');\n    const value = valueParts.join(':');\n    \n    if (key.startsWith('DTSTART')) {\n      currentEvent.dtstart = value.replace(/T.*/, '');\n    } else if (key.startsWith('DTEND')) {\n      currentEvent.dtend = value.replace(/T.*/, '');\n    } else if (key === 'UID') {\n      currentEvent.uid = value;\n    } else if (key === 'SUMMARY') {\n      currentEvent.summary = value;\n    } else if (key === 'DESCRIPTION') {\n      currentEvent.description = value;\n    }\n  }\n}\n\nreturn {\n  property_id: property_id,\n  platform: platform,\n  events_count: events.length,\n  events: events,\n  synced_at: new Date().toISOString()\n};"
      },
      "id": "parse-ical",
      "name": "Parse iCal Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare upsert data for bookings table\nconst allItems = $input.all();\nconst results = [];\n\nfor (const item of allItems) {\n  const data = item.json;\n\n  // Skip items flagged as no-calendar\n  if (data.skip) continue;\n\n  for (const event of (data.events || [])) {\n    // Generate a deterministic booking_id from property + platform + external ID\n    const bookingId = 'ext_' + event.platform + '_' + (event.external_id || '').replace(/[^a-zA-Z0-9_-]/g, '').substring(0, 50);\n\n    results.push({ json: {\n      booking_id: bookingId,\n      property_id: event.property_id,\n      platform: event.platform,\n      guest_name: event.summary || 'Blocked',\n      check_in_date: event.check_in,\n      check_out_date: event.check_out,\n      booking_status: 'confirmed',\n      notes: event.description || 'Synced from ' + event.platform + ' calendar'\n    }});\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { skip: true, message: 'No events to upsert' } }];\n}\n\nreturn results;"
      },
      "id": "prepare-upserts",
      "name": "Prepare Upserts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        112
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO bookings (\n  booking_id, property_id, platform,\n  guest_name, check_in_date, check_out_date, booking_status,\n  channel_type, notes\n)\nVALUES (\n  '{{ $json.booking_id }}',\n  '{{ $json.property_id }}',\n  '{{ $json.platform }}',\n  '{{ $json.guest_name }}',\n  '{{ $json.check_in_date }}',\n  '{{ $json.check_out_date }}',\n  '{{ $json.booking_status || \"confirmed\" }}',\n  'calendar_sync',\n  '{{ ($json.notes || \"\").replace(/'/g, \"''\") }}'\n)\nON CONFLICT (booking_id) DO UPDATE SET\n  guest_name = EXCLUDED.guest_name,\n  check_in_date = EXCLUDED.check_in_date,\n  check_out_date = EXCLUDED.check_out_date,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING booking_id",
        "options": {}
      },
      "id": "upsert-bookings",
      "name": "Upsert External Bookings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1552,
        112
      ],
      "credentials": {
        "postgres": {
          "id": "postgres-cred",
          "name": "[Client] PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=UPDATE property_configurations\nSET last_calendar_sync = CURRENT_TIMESTAMP\nWHERE property_id = '{{ $('Loop Properties').item.json.property_id }}'",
        "options": {}
      },
      "id": "update-sync-time",
      "name": "Update Sync Time",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1760,
        112
      ],
      "credentials": {
        "postgres": {
          "id": "postgres-cred",
          "name": "[Client] PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "list",
          "value": "__WF_ID:WF3: Calendar Manager__",
          "cachedResultName": "WF3: Calendar Manager",
          "cachedResultUrl": "/workflow/pEn69kwNtCEQ21y9"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "property_id": "={{ $('Loop Properties').item.json.property_id }}",
            "action": "check_conflicts"
          },
          "schema": [
            {
              "id": "property_id",
              "displayName": "Property ID",
              "type": "string",
              "required": true
            },
            {
              "id": "action",
              "displayName": "Action",
              "type": "string",
              "required": true
            }
          ]
        },
        "options": {}
      },
      "id": "check-conflicts",
      "name": "Check for Conflicts",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1984,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate iCal export for our bookings\nconst items = $input.all();\n\nlet ical = 'BEGIN:VCALENDAR\\nVERSION:2.0\\nPRODID:-//PropertyManager//EN\\n';\n\nfor (const item of items) {\n  const b = item.json;\n  if (b.booking_id && b.check_in_date && b.check_out_date) {\n    const startDate = b.check_in_date.replace(/-/g, '');\n    const endDate = b.check_out_date.replace(/-/g, '');\n    \n    ical += 'BEGIN:VEVENT\\n';\n    ical += `UID:${b.booking_id}@propertymanager\\n`;\n    ical += `DTSTART;VALUE=DATE:${startDate}\\n`;\n    ical += `DTEND;VALUE=DATE:${endDate}\\n`;\n    ical += `SUMMARY:${b.guest_name || 'Booked'}\\n`;\n    ical += `DESCRIPTION:Booking ID: ${b.booking_id}\\n`;\n    ical += 'END:VEVENT\\n';\n  }\n}\n\nical += 'END:VCALENDAR';\n\nreturn { ical_content: ical, events_exported: items.length };"
      },
      "id": "generate-ical",
      "name": "Generate iCal Export",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        544
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, properties_synced: $('Get Properties with Integrations').all().length, timestamp: $now.toISO() } }}",
        "options": {}
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2208,
        144
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 8
            }
          ]
        }
      },
      "id": "review-trigger",
      "name": "Review Analysis 8 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        480
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  r.review_id, r.platform, r.property_id, r.property_name,\n  r.booking_id, r.guest_name, r.star_rating, r.review_text,\n  r.review_date, p.owner_contact,\n  COALESCE(p.settings->>'preferred_platform', 'telegram') AS preferred_platform,\n  p.customer_id\nFROM reviews r\nLEFT JOIN property_configurations p ON r.property_id = p.property_id\nWHERE r.sentiment IS NULL\n  AND r.review_text IS NOT NULL\n  AND r.review_text != ''\nORDER BY r.received_date DESC\nLIMIT 10",
        "options": {}
      },
      "id": "get-unanalyzed-reviews",
      "name": "Get Unanalyzed Reviews",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        224,
        480
      ],
      "credentials": {
        "postgres": {
          "id": "postgres-cred",
          "name": "[Client] PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Keyword-based sentiment analysis for property reviews\nconst review = $input.item.json;\nconst text = (review.review_text || '').toLowerCase();\n\nconst negativeWords = ['terrible', 'awful', 'dirty', 'broken', 'worst', 'disappointing',\n  'unacceptable', 'rude', 'noise', 'cockroach', 'bug', 'smell', 'mold', 'cold',\n  'uncomfortable', 'overpriced', 'scam', 'avoid', 'never again', 'horrible',\n  'disgusting', 'unsafe', 'dangerous', 'nightmare', 'fraud'];\nconst positiveWords = ['amazing', 'wonderful', 'excellent', 'perfect', 'beautiful',\n  'clean', 'comfortable', 'lovely', 'great', 'fantastic', 'recommend', 'spacious',\n  'cozy', 'friendly', 'helpful', 'quiet', 'stunning', 'delightful', 'convenient',\n  'spotless', 'incredible', 'awesome', 'superb', 'charming'];\n\nlet negCount = 0, posCount = 0;\nconst issues = [], topics = [];\n\nfor (const word of negativeWords) {\n  if (text.includes(word)) { negCount++; issues.push(word); }\n}\nfor (const word of positiveWords) {\n  if (text.includes(word)) { posCount++; topics.push(word); }\n}\n\nconst rating = review.star_rating || 3;\nlet score = (posCount - negCount) + (rating - 3) * 0.5;\nscore = Math.max(-1, Math.min(1, score / 3));\n\nconst sentiment = score >= 0.2 ? 'positive' : score <= -0.2 ? 'negative' : 'neutral';\n\nlet responseDraft = '';\nif (sentiment === 'positive') {\n  responseDraft = 'Thank you for your wonderful review! We are delighted you enjoyed your stay' +\n    (review.property_name ? ' at ' + review.property_name : '') + '. We would love to welcome you back anytime!';\n} else if (sentiment === 'negative') {\n  responseDraft = 'Thank you for your feedback. We sincerely apologize for the issues you experienced. ' +\n    'We take your concerns seriously and are working to address them. ' +\n    'We would love the opportunity to make it right.';\n} else {\n  responseDraft = 'Thank you for taking the time to share your experience. ' +\n    'We appreciate your feedback and are always looking to improve.';\n}\n\nreturn {\n  review_id: review.review_id,\n  property_name: review.property_name,\n  guest_name: review.guest_name,\n  star_rating: rating,\n  sentiment: sentiment,\n  sentiment_score: parseFloat(score.toFixed(2)),\n  topics: JSON.stringify(topics),\n  issues_mentioned: JSON.stringify(issues),\n  confidence: parseFloat((0.5 + Math.min(negCount + posCount, 5) * 0.1).toFixed(2)),\n  response_text: responseDraft,\n  approval_required: sentiment !== 'positive',\n  approval_urgency: sentiment === 'negative' ? 'high' : 'medium',\n  response_status: sentiment === 'positive' ? 'auto_approved' : 'pending_review',\n  owner_contact: review.owner_contact,\n  preferred_platform: review.preferred_platform\n};"
      },
      "id": "analyze-review",
      "name": "Analyze Review Sentiment",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        480
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=UPDATE reviews SET\n  sentiment = '{{ $json.sentiment }}',\n  sentiment_score = {{ $json.sentiment_score }},\n  topics = '{{ $json.topics }}'::jsonb,\n  issues_mentioned = '{{ $json.issues_mentioned }}'::jsonb,\n  confidence = {{ $json.confidence }},\n  response_text = '{{ $json.response_text.replace(/'/g, \"''\") }}',\n  approval_required = {{ $json.approval_required }},\n  approval_urgency = '{{ $json.approval_urgency }}',\n  response_status = '{{ $json.response_status }}',\n  updated_at = CURRENT_TIMESTAMP\nWHERE review_id = '{{ $json.review_id }}'\nRETURNING *",
        "options": {}
      },
      "id": "update-review",
      "name": "Update Review Analysis",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        672,
        480
      ],
      "credentials": {
        "postgres": {
          "id": "postgres-cred",
          "name": "[Client] PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.approval_required }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-negative",
      "name": "Needs Owner Attention?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        896,
        480
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "__WF_ID:SUB: Universal Messenger__",
          "cachedResultName": "SUB: Universal Messenger"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "channel": "={{ $json.preferred_platform || 'telegram' }}",
            "sender_id": "={{ $json.owner_contact || '' }}",
            "input": "=Review Alert ({{ $json.property_name }})\n\nGuest: {{ $json.guest_name }}\nRating: {{ $json.star_rating }}/5\nSentiment: {{ $json.sentiment }}\nPlatform: {{ $json.platform || 'direct' }}\n\nReview: {{ $json.review_text ? $json.review_text.substring(0, 200) : 'N/A' }}\n\nDraft Response: {{ $json.response_text }}\n\nPlease review and approve/edit the response.",
            "customer_id": "={{ $json.customer_id || '' }}"
          },
          "schema": [
            {
              "id": "channel",
              "displayName": "Channel",
              "type": "string",
              "required": true
            },
            {
              "id": "sender_id",
              "displayName": "Sender ID",
              "type": "string",
              "required": true
            },
            {
              "id": "input",
              "displayName": "Input",
              "type": "string",
              "required": true
            },
            {
              "id": "customer_id",
              "displayName": "Customer ID",
              "type": "string",
              "required": true
            }
          ]
        },
        "options": {}
      },
      "id": "notify-owner-review",
      "name": "Notify Owner (Review)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1120,
        400
      ]
    }
  ],
  "connections": {
    "Daily 3 AM Sync": {
      "main": [
        [
          {
            "node": "Get Properties with Integrations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Sync Request": {
      "main": [
        [
          {
            "node": "Get Properties with Integrations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Properties with Integrations": {
      "main": [
        [
          {
            "node": "Loop Properties",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Properties": {
      "main": [
        [
          {
            "node": "Prepare Calendar URLs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Calendar URLs": {
      "main": [
        [
          {
            "node": "Fetch iCal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch iCal": {
      "main": [
        [
          {
            "node": "Parse iCal Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse iCal Data": {
      "main": [
        [
          {
            "node": "Prepare Upserts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Upserts": {
      "main": [
        [
          {
            "node": "Upsert External Bookings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert External Bookings": {
      "main": [
        [
          {
            "node": "Update Sync Time",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Sync Time": {
      "main": [
        [
          {
            "node": "Check for Conflicts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Conflicts": {
      "main": [
        [
          {
            "node": "Loop Properties",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Review Analysis 8 AM": {
      "main": [
        [
          {
            "node": "Get Unanalyzed Reviews",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Unanalyzed Reviews": {
      "main": [
        [
          {
            "node": "Analyze Review Sentiment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Review Sentiment": {
      "main": [
        [
          {
            "node": "Update Review Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Review Analysis": {
      "main": [
        [
          {
            "node": "Needs Owner Attention?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Owner Attention?": {
      "main": [
        [
          {
            "node": "Notify Owner (Review)",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Daily 3 AM Sync": {
      "recurrenceRules": []
    },
    "node:Review Analysis 8 AM": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "pinData": {},
  "activeVersionId": "0ec40c37-f267-4211-82f8-f248e60c12c0",
  "versionCounter": 30,
  "activeVersion": {
    "updatedAt": "2026-02-16T06:25:11.878Z",
    "createdAt": "2026-02-16T06:25:11.878Z",
    "versionId": "0ec40c37-f267-4211-82f8-f248e60c12c0",
    "workflowId": "__WF_ID:WF7: Integration Hub__",
    "nodes": [
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "triggerAtHour": 3
              }
            ]
          }
        },
        "id": "sync-trigger",
        "name": "Daily 3 AM Sync",
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.2,
        "position": [
          0,
          0
        ]
      },
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "integration-sync",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "manual-trigger",
        "name": "Manual Sync Request",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          0,
          208
        ],
        "webhookId": "29e45eca-3f33-4c2f-a1f2-f55f7a2e1f77"
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT\n  property_id,\n  property_name,\n  calendar_url,\n  settings->>'airbnb_calendar_url' AS airbnb_calendar_url,\n  settings->>'vrbo_calendar_url' AS vrbo_calendar_url,\n  settings->>'booking_com_calendar_url' AS booking_com_calendar_url,\n  settings->>'google_calendar_id' AS google_calendar_id,\n  settings->>'ical_export_url' AS ical_export_url,\n  last_calendar_sync,\n  owner_contact,\n  COALESCE(settings->>'preferred_platform', 'telegram') AS preferred_platform,\n  customer_id\nFROM property_configurations\nWHERE property_status = 'active'\n  AND calendar_sync_enabled = true\n  AND (calendar_url IS NOT NULL\n       OR settings->>'airbnb_calendar_url' IS NOT NULL\n       OR settings->>'vrbo_calendar_url' IS NOT NULL\n       OR settings->>'booking_com_calendar_url' IS NOT NULL)",
          "options": {}
        },
        "id": "get-properties",
        "name": "Get Properties with Integrations",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          224,
          112
        ],
        "credentials": {
          "postgres": {
            "id": "postgres-cred",
            "name": "[Client] PostgreSQL"
          }
        }
      },
      {
        "parameters": {
          "options": {}
        },
        "id": "loop-properties",
        "name": "Loop Properties",
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 3,
        "position": [
          448,
          112
        ]
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Prepare calendar URLs for fetching\nconst property = $input.item.json;\nconst calendars = [];\n\nif (property.airbnb_calendar_url) {\n  calendars.push({\n    platform: 'airbnb',\n    url: property.airbnb_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\nif (property.vrbo_calendar_url) {\n  calendars.push({\n    platform: 'vrbo',\n    url: property.vrbo_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\nif (property.booking_com_calendar_url) {\n  calendars.push({\n    platform: 'booking_com',\n    url: property.booking_com_calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\n// Fallback: use the main calendar_url if no platform-specific URLs\nif (calendars.length === 0 && property.calendar_url) {\n  calendars.push({\n    platform: 'ical',\n    url: property.calendar_url,\n    property_id: property.property_id,\n    property_name: property.property_name\n  });\n}\n\n// If no calendar URLs found, return empty with flag\nif (calendars.length === 0) {\n  return [{ json: { property_id: property.property_id, skip: true, reason: 'No calendar URLs configured' } }];\n}\n\nreturn calendars.map(c => ({ json: c }));"
        },
        "id": "prepare-urls",
        "name": "Prepare Calendar URLs",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          672,
          112
        ]
      },
      {
        "parameters": {
          "url": "={{ $json.url }}",
          "options": {
            "timeout": 30000
          }
        },
        "id": "fetch-ical",
        "name": "Fetch iCal",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          880,
          112
        ]
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Parse iCal data and extract events\nconst input = $input.item.json;\nconst icalData = typeof input === 'string' ? input : input.data || '';\nconst property_id = $('Prepare Calendar URLs').item.json.property_id;\nconst platform = $('Prepare Calendar URLs').item.json.platform;\n\nconst events = [];\n\n// Simple iCal parser\nconst lines = icalData.split(/\\r?\\n/);\nlet currentEvent = null;\n\nfor (const line of lines) {\n  if (line.startsWith('BEGIN:VEVENT')) {\n    currentEvent = {};\n  } else if (line.startsWith('END:VEVENT') && currentEvent) {\n    if (currentEvent.dtstart && currentEvent.dtend) {\n      events.push({\n        property_id: property_id,\n        platform: platform,\n        external_id: currentEvent.uid || `${platform}_${Date.now()}`,\n        summary: currentEvent.summary || 'Blocked',\n        check_in: currentEvent.dtstart,\n        check_out: currentEvent.dtend,\n        description: currentEvent.description || ''\n      });\n    }\n    currentEvent = null;\n  } else if (currentEvent) {\n    const [key, ...valueParts] = line.split(':');\n    const value = valueParts.join(':');\n    \n    if (key.startsWith('DTSTART')) {\n      currentEvent.dtstart = value.replace(/T.*/, '');\n    } else if (key.startsWith('DTEND')) {\n      currentEvent.dtend = value.replace(/T.*/, '');\n    } else if (key === 'UID') {\n      currentEvent.uid = value;\n    } else if (key === 'SUMMARY') {\n      currentEvent.summary = value;\n    } else if (key === 'DESCRIPTION') {\n      currentEvent.description = value;\n    }\n  }\n}\n\nreturn {\n  property_id: property_id,\n  platform: platform,\n  events_count: events.length,\n  events: events,\n  synced_at: new Date().toISOString()\n};"
        },
        "id": "parse-ical",
        "name": "Parse iCal Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1104,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare upsert data for bookings table\nconst allItems = $input.all();\nconst results = [];\n\nfor (const item of allItems) {\n  const data = item.json;\n\n  // Skip items flagged as no-calendar\n  if (data.skip) continue;\n\n  for (const event of (data.events || [])) {\n    // Generate a deterministic booking_id from property + platform + external ID\n    const bookingId = 'ext_' + event.platform + '_' + (event.external_id || '').replace(/[^a-zA-Z0-9_-]/g, '').substring(0, 50);\n\n    results.push({ json: {\n      booking_id: bookingId,\n      property_id: event.property_id,\n      platform: event.platform,\n      guest_name: event.summary || 'Blocked',\n      check_in_date: event.check_in,\n      check_out_date: event.check_out,\n      booking_status: 'confirmed',\n      notes: event.description || 'Synced from ' + event.platform + ' calendar'\n    }});\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { skip: true, message: 'No events to upsert' } }];\n}\n\nreturn results;"
        },
        "id": "prepare-upserts",
        "name": "Prepare Upserts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1328,
          112
        ]
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=INSERT INTO bookings (\n  booking_id, property_id, platform,\n  guest_name, check_in_date, check_out_date, booking_status,\n  channel_type, notes\n)\nVALUES (\n  '{{ $json.booking_id }}',\n  '{{ $json.property_id }}',\n  '{{ $json.platform }}',\n  '{{ $json.guest_name }}',\n  '{{ $json.check_in_date }}',\n  '{{ $json.check_out_date }}',\n  '{{ $json.booking_status || \"confirmed\" }}',\n  'calendar_sync',\n  '{{ ($json.notes || \"\").replace(/'/g, \"''\") }}'\n)\nON CONFLICT (booking_id) DO UPDATE SET\n  guest_name = EXCLUDED.guest_name,\n  check_in_date = EXCLUDED.check_in_date,\n  check_out_date = EXCLUDED.check_out_date,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING booking_id",
          "options": {}
        },
        "id": "upsert-bookings",
        "name": "Upsert External Bookings",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          1552,
          112
        ],
        "credentials": {
          "postgres": {
            "id": "postgres-cred",
            "name": "[Client] PostgreSQL"
          }
        }
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=UPDATE property_configurations\nSET last_calendar_sync = CURRENT_TIMESTAMP\nWHERE property_id = '{{ $('Loop Properties').item.json.property_id }}'",
          "options": {}
        },
        "id": "update-sync-time",
        "name": "Update Sync Time",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          1760,
          112
        ],
        "credentials": {
          "postgres": {
            "id": "postgres-cred",
            "name": "[Client] PostgreSQL"
          }
        }
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "list",
            "value": "__WF_ID:WF3: Calendar Manager__",
            "cachedResultName": "WF3: Calendar Manager",
            "cachedResultUrl": "/workflow/pEn69kwNtCEQ21y9"
          },
          "options": {},
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "property_id": "={{ $('Loop Properties').item.json.property_id }}",
              "action": "check_conflicts"
            },
            "schema": [
              {
                "id": "property_id",
                "displayName": "Property ID",
                "type": "string",
                "required": true
              },
              {
                "id": "action",
                "displayName": "Action",
                "type": "string",
                "required": true
              }
            ]
          }
        },
        "id": "check-conflicts",
        "name": "Check for Conflicts",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          1984,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Generate iCal export for our bookings\nconst items = $input.all();\n\nlet ical = 'BEGIN:VCALENDAR\\nVERSION:2.0\\nPRODID:-//PropertyManager//EN\\n';\n\nfor (const item of items) {\n  const b = item.json;\n  if (b.booking_id && b.check_in_date && b.check_out_date) {\n    const startDate = b.check_in_date.replace(/-/g, '');\n    const endDate = b.check_out_date.replace(/-/g, '');\n    \n    ical += 'BEGIN:VEVENT\\n';\n    ical += `UID:${b.booking_id}@propertymanager\\n`;\n    ical += `DTSTART;VALUE=DATE:${startDate}\\n`;\n    ical += `DTEND;VALUE=DATE:${endDate}\\n`;\n    ical += `SUMMARY:${b.guest_name || 'Booked'}\\n`;\n    ical += `DESCRIPTION:Booking ID: ${b.booking_id}\\n`;\n    ical += 'END:VEVENT\\n';\n  }\n}\n\nical += 'END:VCALENDAR';\n\nreturn { ical_content: ical, events_exported: items.length };"
        },
        "id": "generate-ical",
        "name": "Generate iCal Export",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          688,
          320
        ]
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ { success: true, properties_synced: $('Get Properties with Integrations').all().length, timestamp: $now.toISO() } }}",
          "options": {}
        },
        "id": "respond",
        "name": "Respond",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          2208,
          112
        ]
      },
      {
        "id": "review-trigger",
        "name": "Review Analysis 8 AM",
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.2,
        "position": [
          0,
          480
        ],
        "parameters": {
          "rule": {
            "interval": [
              {
                "triggerAtHour": 8
              }
            ]
          }
        }
      },
      {
        "id": "get-unanalyzed-reviews",
        "name": "Get Unanalyzed Reviews",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          224,
          480
        ],
        "parameters": {
          "operation": "executeQuery",
          "query": "SELECT\n  r.review_id, r.platform, r.property_id, r.property_name,\n  r.booking_id, r.guest_name, r.star_rating, r.review_text,\n  r.review_date, p.owner_contact,\n  COALESCE(p.settings->>'preferred_platform', 'telegram') AS preferred_platform,\n  p.customer_id\nFROM reviews r\nLEFT JOIN property_configurations p ON r.property_id = p.property_id\nWHERE r.sentiment IS NULL\n  AND r.review_text IS NOT NULL\n  AND r.review_text != ''\nORDER BY r.received_date DESC\nLIMIT 10",
          "options": {}
        },
        "credentials": {
          "postgres": {
            "id": "postgres-cred",
            "name": "[Client] PostgreSQL"
          }
        }
      },
      {
        "id": "analyze-review",
        "name": "Analyze Review Sentiment",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          448,
          480
        ],
        "parameters": {
          "jsCode": "// Keyword-based sentiment analysis for property reviews\nconst review = $input.item.json;\nconst text = (review.review_text || '').toLowerCase();\n\nconst negativeWords = ['terrible', 'awful', 'dirty', 'broken', 'worst', 'disappointing',\n  'unacceptable', 'rude', 'noise', 'cockroach', 'bug', 'smell', 'mold', 'cold',\n  'uncomfortable', 'overpriced', 'scam', 'avoid', 'never again', 'horrible',\n  'disgusting', 'unsafe', 'dangerous', 'nightmare', 'fraud'];\nconst positiveWords = ['amazing', 'wonderful', 'excellent', 'perfect', 'beautiful',\n  'clean', 'comfortable', 'lovely', 'great', 'fantastic', 'recommend', 'spacious',\n  'cozy', 'friendly', 'helpful', 'quiet', 'stunning', 'delightful', 'convenient',\n  'spotless', 'incredible', 'awesome', 'superb', 'charming'];\n\nlet negCount = 0, posCount = 0;\nconst issues = [], topics = [];\n\nfor (const word of negativeWords) {\n  if (text.includes(word)) { negCount++; issues.push(word); }\n}\nfor (const word of positiveWords) {\n  if (text.includes(word)) { posCount++; topics.push(word); }\n}\n\nconst rating = review.star_rating || 3;\nlet score = (posCount - negCount) + (rating - 3) * 0.5;\nscore = Math.max(-1, Math.min(1, score / 3));\n\nconst sentiment = score >= 0.2 ? 'positive' : score <= -0.2 ? 'negative' : 'neutral';\n\nlet responseDraft = '';\nif (sentiment === 'positive') {\n  responseDraft = 'Thank you for your wonderful review! We are delighted you enjoyed your stay' +\n    (review.property_name ? ' at ' + review.property_name : '') + '. We would love to welcome you back anytime!';\n} else if (sentiment === 'negative') {\n  responseDraft = 'Thank you for your feedback. We sincerely apologize for the issues you experienced. ' +\n    'We take your concerns seriously and are working to address them. ' +\n    'We would love the opportunity to make it right.';\n} else {\n  responseDraft = 'Thank you for taking the time to share your experience. ' +\n    'We appreciate your feedback and are always looking to improve.';\n}\n\nreturn {\n  review_id: review.review_id,\n  property_name: review.property_name,\n  guest_name: review.guest_name,\n  star_rating: rating,\n  sentiment: sentiment,\n  sentiment_score: parseFloat(score.toFixed(2)),\n  topics: JSON.stringify(topics),\n  issues_mentioned: JSON.stringify(issues),\n  confidence: parseFloat((0.5 + Math.min(negCount + posCount, 5) * 0.1).toFixed(2)),\n  response_text: responseDraft,\n  approval_required: sentiment !== 'positive',\n  approval_urgency: sentiment === 'negative' ? 'high' : 'medium',\n  response_status: sentiment === 'positive' ? 'auto_approved' : 'pending_review',\n  owner_contact: review.owner_contact,\n  preferred_platform: review.preferred_platform\n};"
        }
      },
      {
        "id": "update-review",
        "name": "Update Review Analysis",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.5,
        "position": [
          672,
          480
        ],
        "parameters": {
          "operation": "executeQuery",
          "query": "=UPDATE reviews SET\n  sentiment = '{{ $json.sentiment }}',\n  sentiment_score = {{ $json.sentiment_score }},\n  topics = '{{ $json.topics }}'::jsonb,\n  issues_mentioned = '{{ $json.issues_mentioned }}'::jsonb,\n  confidence = {{ $json.confidence }},\n  response_text = '{{ $json.response_text.replace(/'/g, \"''\") }}',\n  approval_required = {{ $json.approval_required }},\n  approval_urgency = '{{ $json.approval_urgency }}',\n  response_status = '{{ $json.response_status }}',\n  updated_at = CURRENT_TIMESTAMP\nWHERE review_id = '{{ $json.review_id }}'\nRETURNING *",
          "options": {}
        },
        "credentials": {
          "postgres": {
            "id": "postgres-cred",
            "name": "[Client] PostgreSQL"
          }
        }
      },
      {
        "id": "check-negative",
        "name": "Needs Owner Attention?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          896,
          480
        ],
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": false,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "leftValue": "={{ $json.approval_required }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "true"
                }
              }
            ],
            "combinator": "and"
          }
        }
      },
      {
        "id": "notify-owner-review",
        "name": "Notify Owner (Review)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          1120,
          400
        ],
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "__WF_ID:SUB: Universal Messenger__"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "channel": "={{ $json.preferred_platform || 'telegram' }}",
              "sender_id": "={{ $json.owner_contact || '' }}",
              "input": "=Review Alert ({{ $json.property_name }})\n\nGuest: {{ $json.guest_name }}\nRating: {{ $json.star_rating }}/5\nSentiment: {{ $json.sentiment }}\nPlatform: {{ $json.platform || 'direct' }}\n\nReview: {{ $json.review_text ? $json.review_text.substring(0, 200) : 'N/A' }}\n\nDraft Response: {{ $json.response_text }}\n\nPlease review and approve/edit the response.",
              "customer_id": "={{ $json.customer_id || '' }}"
            },
            "schema": [
              {
                "id": "channel",
                "displayName": "Channel",
                "type": "string",
                "required": true
              },
              {
                "id": "sender_id",
                "displayName": "Sender ID",
                "type": "string",
                "required": true
              },
              {
                "id": "input",
                "displayName": "Input",
                "type": "string",
                "required": true
              },
              {
                "id": "customer_id",
                "displayName": "Customer ID",
                "type": "string",
                "required": true
              }
            ]
          },
          "options": {}
        }
      }
    ],
    "connections": {
      "Daily 3 AM Sync": {
        "main": [
          [
            {
              "node": "Get Properties with Integrations",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Manual Sync Request": {
        "main": [
          [
            {
              "node": "Get Properties with Integrations",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Properties with Integrations": {
        "main": [
          [
            {
              "node": "Loop Properties",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Loop Properties": {
        "main": [
          [
            {
              "node": "Prepare Calendar URLs",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Respond",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Calendar URLs": {
        "main": [
          [
            {
              "node": "Fetch iCal",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch iCal": {
        "main": [
          [
            {
              "node": "Parse iCal Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse iCal Data": {
        "main": [
          [
            {
              "node": "Prepare Upserts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Upserts": {
        "main": [
          [
            {
              "node": "Upsert External Bookings",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upsert External Bookings": {
        "main": [
          [
            {
              "node": "Update Sync Time",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Sync Time": {
        "main": [
          [
            {
              "node": "Check for Conflicts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check for Conflicts": {
        "main": [
          [
            {
              "node": "Loop Properties",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Review Analysis 8 AM": {
        "main": [
          [
            {
              "node": "Get Unanalyzed Reviews",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Unanalyzed Reviews": {
        "main": [
          [
            {
              "node": "Analyze Review Sentiment",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Analyze Review Sentiment": {
        "main": [
          [
            {
              "node": "Update Review Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Review Analysis": {
        "main": [
          [
            {
              "node": "Needs Owner Attention?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Needs Owner Attention?": {
        "main": [
          [
            {
              "node": "Notify Owner (Review)",
              "type": "main",
              "index": 0
            }
          ],
          []
        ]
      }
    },
    "authors": "Gabriel Erna",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-16T06:25:13.377Z",
        "id": 289,
        "workflowId": "__WF_ID:WF7: Integration Hub__",
        "versionId": "0ec40c37-f267-4211-82f8-f248e60c12c0",
        "event": "activated",
        "userId": "953ba085-e3b3-41f0-8479-98dd4f06f8a7"
      }
    ]
  }
}